<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Settings - SoundApp</title>
    <link media="all" rel="stylesheet" type="text/css" href="../css/fonts.css">
    <link media="all" rel="stylesheet" type="text/css" href="../libs/nui/css/nui_main.css">
    <link media="all" rel="stylesheet" type="text/css" href="../libs/nui/css/nui_app.css">
    <link rel="stylesheet" href="../css/window.css">
</head>

<body class="dark">
    <div class="nui-app">
        <div class="nui-title-bar">
            <div class="title">
                <div class="nui-icon-container">
                    <i>settings</i>
                </div>
                <div class="label">Settings</div>
            </div>
            <div class="controls">
                <div class="nui-icon-container close"><i>close</i></div>
            </div>
        </div>
        <div class="content settings">
            <main>
                <div class="settings-column">
                    <div class="nui-card">
                        <section class="settings-section">
                            <h2>General</h2>
                            <div class="nui-checkbox">
                                <input type="checkbox" id="darkThemeToggle">
                                <label for="darkThemeToggle">
                                    <strong>Dark Theme</strong>
                                </label>
                            </div>
                            <div class="setting-description">
                                Switch between dark and light theme. Alternative to the Ctrl+X keyboard shortcut.
                            </div>
                            </section>
                            <hr>
                            <section class="settings-section">
                            <div class="nui-input">
                                <div>
                                    <label>Default Directory</label>
                                    <div class="browse-input">
                                        <div style="position: relative; display: flex; align-items: center;">
                                            <input type="text" id="defaultDirInput" readonly placeholder="No directory set" style="width: 100%; padding-right: 2.5rem;">
                                            <div id="clearDirBtn" class="nui-icon-container" style="position: absolute; right: 0.5rem; cursor: pointer; display: none; opacity: 0.7;">
                                                <i>close</i>
                                            </div>
                                        </div>
                                        <button id="browseBtn" type="button">Browse...</button>
                                    </div>
								<div class="setting-description">
									Optional start folder used for file dialogs and drag & drop convenience.
								</div>
                                </div>
                            </div>
                            <hr>
                            </section>
                             <section class="settings-section">
                        <div class="nui-checkbox" style="margin-top: 1rem;">
                            <input type="checkbox" id="keepRunningInTrayToggle">
                            <label for="keepRunningInTrayToggle">
                                <strong>Keep running in tray</strong>
                            </label>
                        </div>
                        <div class="setting-description">
                            When enabled, closing the main window will hide SoundApp to the tray instead of exiting. Useful for faster restart.
                        </div>
                        </section>
                    </div>
                    
                    <div class="nui-card">
                        <section class="settings-section">
                            <h2>File Associations</h2>
                            <div class="nui-button-container">
                                <button id="registerFilesBtn" type="button" class="nui-button">Register File Types</button>
                                <button id="unregisterFilesBtn" type="reset" class="nui-button secondary">Unregister File Types</button>
                            </div>
                            <div class="restart-notice" id="registryNotice">
                                Done!
                            </div>
                            <div class="setting-description" style="margin-bottom: 1rem;">
                                Register SoundApp as the default handler for supported audio file types in Windows Explorer.
                            </div>
                        </section>
                    </div>

                    <div class="nui-card">
                        <section>
                            <h2>Module / Tracker</h2>
                            <div class="nui-input">
                                <label>MOD Stereo Separation</label>
                                <select id="modStereoSeparationSelect">
                                    <option value="0">0% (Mono)</option>
                                    <option value="25">25%</option>
                                    <option value="50">50%</option>
                                    <option value="75">75%</option>
                                    <option value="100" selected>100% (Full Amiga stereo)</option>
                                </select>
                                <div class="setting-description">
                                    Stereo width control for tracker/module formats (MOD, XM, S3M, IT). 0% = mono, 100% = full Amiga-style hard stereo panning. Affects MOD files only. Changing this reloads the current file.
                                </div>
                            </div>

                            <div class="nui-input">
                                <label>MOD Interpolation Filter</label>
                                <select id="modInterpolationFilterSelect">
                                    <option value="0" selected>Internal default</option>
                                    <option value="1">No interpolation (zero order hold)</option>
                                    <option value="2">Linear interpolation</option>
                                    <option value="4">Cubic interpolation</option>
                                    <option value="8">Windowed sinc (8 taps, highest quality)</option>
                                </select>
                                <div class="setting-description">
                                    Sample interpolation quality for tracker/module formats. Higher quality reduces aliasing artifacts at the cost of slightly more CPU usage. Affects MOD files only. Changing this reloads the current file.
                                </div>
                            </div>
                        </section>
                    </div>
                </div>

                <div class="settings-column">
                    

                    <div class="nui-card">
                        <section class="settings-section">
                            <h2>Audio / Quality</h2>
                            
                            <div class="nui-checkbox">
                                <input type="checkbox" id="hqModeToggle">
                                <label for="hqModeToggle">
                                    <strong>Max output sample rate</strong><span style="padding-left: 0.5rem;">(up to device max)</span>
                                </label>
                            </div>
                            <div class="restart-notice" id="hqRestartNotice">
                                Switching audio system...
                            </div>

                            <div class="info-box">
                                <strong>Audio System Info</strong><br>
                                Max supported sample rate: <strong id="maxSampleRate">--</strong><br>
                                Current AudioContext rate: <strong id="currentSampleRate">--</strong>
                            </div>

                            <div class="nui-input">
                                <label>Output Device</label>
                                <select id="outputDeviceSelect">
                                    <option value="">System Default</option>
                                </select>
                                <div class="setting-description">
                                    Choose which audio interface to use for playback. Useful for professionals with multiple interfaces (monitors, headphones, external DACs). Changes take effect immediately.
                                </div>
                            </div>
                            
                            <div class="restart-notice" id="deviceChangeNotice">
                                Switching output device...
                            </div>
                        </section>
                    </div>

                    <div class="nui-card">
                        <section>
                            <h2>Streaming</h2>
                            <div class="nui-input">
                                <label>Buffer Size (chunks)</label>
                                <select id="bufferSizeSelect">
                                    <option value="5">5 (~0.5 sec)</option>
                                    <option value="10" selected>10 (~1 sec) - Default</option>
                                    <option value="15">15 (~1.5 sec)</option>
                                    <option value="20">20 (~2 sec)</option>
                                    <option value="25">25 (~2.5 sec)</option>
                                    <option value="30">30 (~3 sec)</option>
                                    <option value="35">35 (~3.5 sec)</option>
                                    <option value="40">40 (~4 sec)</option>
                                    <option value="45">45 (~4.5 sec)</option>
                                    <option value="50">50 (~5 sec)</option>
                                    <option value="55">55 (~5.5 sec)</option>
                                    <option value="60">60 (~6 sec)</option>
                                </select>
                                <div class="setting-description">
                                    Amount of audio buffered ahead during streaming playback. Higher values prevent dropouts on slower systems or during CPU spikes, but use slightly more memory. Lower values reduce latency. Default works well for most systems.
                                </div>
                            </div>

                            <div class="nui-input">
                                <label>Decoder Threads</label>
                                <select id="decoderThreadsSelect">
                                    <option value="0" selected>Auto (detect CPU cores)</option>
                                    <option value="1">1 thread (minimal CPU)</option>
                                    <option value="2">2 threads</option>
                                    <option value="4">4 threads</option>
                                    <option value="8">8 threads</option>
                                </select>
                                <div class="setting-description">
                                    Number of CPU threads for FFmpeg audio decoding. Auto mode uses all available cores for best performance. Lower values reduce CPU usage on slower systems. Changes take effect when loading the next file.
                                </div>
                            </div>
                        </section>
                    </div>

                    <div class="nui-card">
                        <section>
                            <h2>Mixer</h2>
                            <div class="nui-input">
                                <label>Sync Pre-Buffer (ms)</label>
                                <select id="mixerPreBufferSelect">
                                    <option value="50" selected>50ms (Default - Lowest latency)</option>
                                    <option value="100">100ms</option>
                                    <option value="150">150ms</option>
                                    <option value="200">200ms</option>
                                    <option value="250">250ms</option>
                                    <option value="300">300ms (Safest)</option>
                                </select>
                                <div class="setting-description">
                                    Pre-roll buffer time to ensure synchronous start of all tracks. Increase this value if you experience sync issues or stuttering at the start of playback.
                                </div>
                            </div>
                        </section>
                    </div>
                </div>
            </main>
        </div>
        <div class="nui-status-bar"></div>
    </div>

    <script type="module">
        import ut from '../libs/nui/nui_ut.js';
        import superSelect from '../libs/nui/nui_select.js';
        window.ut = ut;
        window.superSelect = superSelect;
    </script>
    <script src="../js/window-loader.js"></script>
    <script>
        // Settings window initialization
        window.addEventListener('bridge-ready', (e) => {
            const data = e.detail;
            const bridge = window.bridge;
            
            // Load shortcuts module (only in Electron)
            if (bridge.isElectron) {
                const shortcuts = require('../js/shortcuts.js');
                
                // Handle keyboard shortcuts
                window.addEventListener('keydown', (keyEvent) => {
                    shortcuts.handleShortcut(keyEvent, 'settings');
                });
            }
            
            initSettings(data);
        });

        function initSettings(data) {
            const bridge = window.bridge;
            let config = data.config || {};
            const config_obj = data.config_obj || null;

            function getCfg(path, fallback) {
                let cur = config;
                for (let i = 0; i < path.length; i++) {
                    if (!cur || typeof cur !== 'object') return fallback;
                    cur = cur[path[i]];
                }
                return cur === undefined ? fallback : cur;
            }

            function setCfgValue(path, value) {
                if (!path || !path.length) return;
                const cur = config_obj ? (config_obj.get() || {}) : (config || {});
                const next = { ...cur };

                let dst = next;
                for (let i = 0; i < path.length - 1; i++) {
                    const k = path[i];
                    const child = (dst[k] && typeof dst[k] === 'object') ? dst[k] : {};
                    dst[k] = { ...child };
                    dst = dst[k];
                }
                dst[path[path.length - 1]] = value;

                if (config_obj) {
                    config_obj.set(next);
                }
                config = next;
            }
            
            // Display audio system info
            if (data.maxSampleRate) {
                document.getElementById('maxSampleRate').textContent = data.maxSampleRate + ' Hz';
            }
            if (data.currentSampleRate) {
                document.getElementById('currentSampleRate').textContent = data.currentSampleRate + ' Hz';
            }
            
            // HQ Mode Toggle
            const hqToggle = document.getElementById('hqModeToggle');
            const hqNotice = document.getElementById('hqRestartNotice');
            if (getCfg(['audio', 'hqMode'], false)) {
                hqToggle.checked = true;
            }

            hqToggle.addEventListener('change', () => {
                setCfgValue(['audio', 'hqMode'], !!hqToggle.checked);
                hqNotice.classList.add('visible');
                
                setTimeout(() => {
                    hqNotice.classList.remove('visible');
                }, 3000);
            });

            // Dark Theme Toggle
            const darkThemeToggle = document.getElementById('darkThemeToggle');
            if (getCfg(['ui', 'theme'], 'dark') === 'dark') {
                darkThemeToggle.checked = true;
            }

            darkThemeToggle.addEventListener('change', () => {
                setCfgValue(['ui', 'theme'], darkThemeToggle.checked ? 'dark' : 'light');
            });

            // Keep running in tray
            const keepRunningInTrayToggle = document.getElementById('keepRunningInTrayToggle');
            if(keepRunningInTrayToggle){
                keepRunningInTrayToggle.checked = !!getCfg(['ui', 'keepRunningInTray'], false);
                keepRunningInTrayToggle.addEventListener('change', () => {
                    setCfgValue(['ui', 'keepRunningInTray'], !!keepRunningInTrayToggle.checked);
                });
            }

            // Listen for theme changes from main process
            bridge.on('theme-changed', (data) => {
                darkThemeToggle.checked = data.dark;
                if (data.dark) {
                    document.body.classList.add('dark');
                } else {
                    document.body.classList.remove('dark');
                }
            });

            // Listen for sample rate updates
            bridge.on('sample-rate-updated', (data) => {
                if (data.currentSampleRate) {
                    document.getElementById('currentSampleRate').textContent = data.currentSampleRate + ' Hz';
                }
            });

            // Output Device Selection
            const deviceSelect = document.getElementById('outputDeviceSelect');
            const deviceNotice = document.getElementById('deviceChangeNotice');
            let deviceSelectWidget = null;
            
            // Enumerate audio devices
            async function loadAudioDevices() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const audioOutputs = devices.filter(d => {
                        if (d.kind !== 'audiooutput') return false;
                        // Filter out Communications devices
                        if (d.label && d.label.toLowerCase().includes('communications')) return false;
                        return true;
                    });
                    
                    // Build options array for superSelect
                    const options = [
                        { name: 'System Default', value: '', selected: !getCfg(['audio','output','deviceId'], '') }
                    ];
                    
                    audioOutputs.forEach(device => {
                        // Skip if it's a duplicate "System Default" or "Default" device
                        const label = device.label || `Device ${device.deviceId.substring(0, 8)}`;
                        if (label.toLowerCase().includes('system default') || label.toLowerCase() === 'default') {
                            return;
                        }
                        
                        options.push({
                            name: label,
                            value: device.deviceId,
                            selected: device.deviceId === getCfg(['audio','output','deviceId'], '')
                        });
                    });
                    
                    // Clear and rebuild select
                    deviceSelect.innerHTML = '';
                    options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.name;
                        if (opt.selected) option.selected = true;
                        deviceSelect.appendChild(option);
                    });
                    
                    // Initialize or update superSelect widget
                    if (!deviceSelectWidget) {
                        deviceSelectWidget = superSelect(deviceSelect, {
                            searchable: false
                        });
                    } else {
                        deviceSelectWidget.reRender();
                    }
                    
                    // Check if configured device still exists
                    const currentDevId = getCfg(['audio','output','deviceId'], '');
                    if (currentDevId) {
                        const deviceExists = audioOutputs.some(d => d.deviceId === currentDevId);
                        if (!deviceExists) {
                            console.log('Configured output device not found, using system default');
                        }
                    }
                } catch (err) {
                    console.error('Failed to enumerate devices:', err);
                }
            }
            
            loadAudioDevices();
            
            // Listen for device changes
            navigator.mediaDevices.addEventListener('devicechange', loadAudioDevices);
            
            // Handle device selection
            deviceSelect.addEventListener('change', () => {
                const deviceId = deviceSelect.value;
                setCfgValue(['audio','output','deviceId'], deviceId || '');
                deviceNotice.classList.add('visible');
                
                setTimeout(() => {
                    deviceNotice.classList.remove('visible');
                }, 2000);
            });

            // Buffer Size Selection
            const bufferSizeSelect = document.getElementById('bufferSizeSelect');
            let bufferSizeWidget = null;
            
            // Set current value from config (default: 10)
            bufferSizeSelect.value = getCfg(['ffmpeg','stream','prebufferChunks'], 10);
            
            // Initialize superSelect
            bufferSizeWidget = superSelect(bufferSizeSelect, {
                searchable: false
            });
            
            // Handle buffer size change with debounce
            let bufferChangeTimeout = null;
            bufferSizeSelect.addEventListener('change', () => {
                clearTimeout(bufferChangeTimeout);
                bufferChangeTimeout = setTimeout(() => {
                    const bufferSize = parseInt(bufferSizeSelect.value);
                    setCfgValue(['ffmpeg','stream','prebufferChunks'], bufferSize);
                }, 200); // 200ms debounce
            });

            // Decoder Threads Selection
            const decoderThreadsSelect = document.getElementById('decoderThreadsSelect');
            let decoderThreadsWidget = null;
            
            // Set current value from config (default: 0 = auto)
            decoderThreadsSelect.value = getCfg(['ffmpeg','decoder','threads'], 0);
            
            // Initialize superSelect
            decoderThreadsWidget = superSelect(decoderThreadsSelect, {
                searchable: false
            });
            
            // Handle decoder threads change with debounce
            let threadsChangeTimeout = null;
            decoderThreadsSelect.addEventListener('change', () => {
                clearTimeout(threadsChangeTimeout);
                threadsChangeTimeout = setTimeout(() => {
                    const threadCount = parseInt(decoderThreadsSelect.value);
                    setCfgValue(['ffmpeg','decoder','threads'], threadCount);
                }, 200); // 200ms debounce
            });

            // Mixer Pre-Buffer Selection
            const mixerPreBufferSelect = document.getElementById('mixerPreBufferSelect');
            let mixerPreBufferWidget = null;
            
            // Set current value from config (default: 50)
            mixerPreBufferSelect.value = getCfg(['mixer','preBuffer'], 50);
            
            // Initialize superSelect
            mixerPreBufferWidget = superSelect(mixerPreBufferSelect, {
                searchable: false
            });
            
            // Handle pre-buffer change with debounce
            let preBufferChangeTimeout = null;
            mixerPreBufferSelect.addEventListener('change', () => {
                clearTimeout(preBufferChangeTimeout);
                preBufferChangeTimeout = setTimeout(() => {
                    const preBuffer = parseInt(mixerPreBufferSelect.value);
                    setCfgValue(['mixer','preBuffer'], preBuffer);
                }, 200); // 200ms debounce
            });

            // MOD Stereo Separation Selection
            const modStereoSeparationSelect = document.getElementById('modStereoSeparationSelect');
            let modStereoSeparationWidget = null;
            
            // Set current value from config (default: 100)
            modStereoSeparationSelect.value = getCfg(['tracker','stereoSeparation'], 100);
            
            // Initialize superSelect
            modStereoSeparationWidget = superSelect(modStereoSeparationSelect, {
                searchable: false
            });
            
            // Handle stereo separation change with debounce
            let stereoSeparationChangeTimeout = null;
            modStereoSeparationSelect.addEventListener('change', () => {
                clearTimeout(stereoSeparationChangeTimeout);
                stereoSeparationChangeTimeout = setTimeout(() => {
                    const stereoSeparation = parseInt(modStereoSeparationSelect.value);
                    setCfgValue(['tracker','stereoSeparation'], stereoSeparation);
                }, 200); // 200ms debounce
            });

            // MOD Interpolation Filter Selection
            const modInterpolationFilterSelect = document.getElementById('modInterpolationFilterSelect');
            let modInterpolationFilterWidget = null;
            
            // Set current value from config (default: 0)
            modInterpolationFilterSelect.value = getCfg(['tracker','interpolationFilter'], 0);
            
            // Initialize superSelect
            modInterpolationFilterWidget = superSelect(modInterpolationFilterSelect, {
                searchable: false
            });
            
            // Handle interpolation filter change with debounce
            let interpolationFilterChangeTimeout = null;
            modInterpolationFilterSelect.addEventListener('change', () => {
                clearTimeout(interpolationFilterChangeTimeout);
                interpolationFilterChangeTimeout = setTimeout(() => {
                    const interpolationFilter = parseInt(modInterpolationFilterSelect.value);
                    setCfgValue(['tracker','interpolationFilter'], interpolationFilter);
                }, 200); // 200ms debounce
            });

            // Default Directory
            const dirInput = document.getElementById('defaultDirInput');
            const browseBtn = document.getElementById('browseBtn');
            const clearDirBtn = document.getElementById('clearDirBtn');
            
            function updateClearBtn() {
                clearDirBtn.style.display = dirInput.value ? 'flex' : 'none';
            }

            const cfgDir = getCfg(['ui','defaultDir'], '');
            if (cfgDir) {
                dirInput.value = cfgDir;
            }
            updateClearBtn();

            browseBtn.addEventListener('click', () => {
                bridge.sendToStage('browse-directory', {});
            });
            
            clearDirBtn.addEventListener('click', () => {
                dirInput.value = '';
                updateClearBtn();
                setCfgValue(['ui','defaultDir'], '');
            });

            // Listen for directory selection
            bridge.on('directory-selected', (dirPath) => {
                dirInput.value = dirPath;
                updateClearBtn();
                setCfgValue(['ui','defaultDir'], dirPath);
            });

            // File Associations
            const registerBtn = document.getElementById('registerFilesBtn');
            const unregisterBtn = document.getElementById('unregisterFilesBtn');
            const registryNotice = document.getElementById('registryNotice');

            registerBtn.addEventListener('click', () => {
                bridge.sendToStage('register-file-types', {});
            });

            unregisterBtn.addEventListener('click', () => {
                bridge.sendToStage('unregister-file-types', {});
            });

            bridge.on('registry-action-complete', (data) => {
                registryNotice.textContent = data.success ? 'Done!' : 'Failed: ' + data.error;
                registryNotice.classList.add('visible');
                setTimeout(() => {
                    registryNotice.classList.remove('visible');
                }, 2000);
            });
        }
    </script>
</body>

</html>
